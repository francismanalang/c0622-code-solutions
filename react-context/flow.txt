# Database Setup
  * Postgresql is used to create the database reactContext for the information within schema.sql
  * Back-end server code is set up on server/index.js
    - Within index.js, two post routes are defined to respond to the client for when the user is Signing Up and Signing In
      * Sign up
        - If the client did NOT provide a valid user name and password, a ClientError is sent
        - If the client did provide valid inputs, argon2 is used to hash the provided password
        - then, sql code is used to insert the username and hashedPassword into the database
        - userId, username, and createdAt is returned and sent back to the client
      * Sign in
        - If the client did NOT provide a valid user name and password, a ClientError is sent
        - If the client did provide valid inputs, we query the database using sql code to return the userId and hashedPassword from that speciifc username
        - argon2 is used to verify if the hashedPassword and the password provided by the user matches
        - if they do match, a payload is created containing the userId and username
        - jwt.sign() is used to sign a token using the TOKEN_SECRET specified in the env file
        - An object containing the signed token and payload are returned to the client

# Notes
  * Front end is SERVED by the back-end
  * When users go to a website, the browser sends a GET request for an HTML Document.
  * HTML Document includes
    - BootStrap link
    - Font Awesome link
    - Stylesheet link
    - A script for a main.js file
  * Main.js does not is exist but is handled by dev-middelware.js (which includes a bundle of all the client modules and creates a main.js for us)
  * Once the browser recieves the JavaScript code (includes all the indiviual client modules), our front end code will start to get executed.

# Front-End Code
  * index.jsx
    - React, ReactDOM, and the App Component are included in the bundle
    - The root div is grabbed from the HTML Document
    - We create a react root and the application is started by mounting the App component to the root div

  * app.jsx
    - The mounting phase is started in the component lifecycle.
    - The contructor within app.jsx is executed which establishes an initial state. The initial state has:
      a. a property named user with a value of null
      b. a property isAuthorizing and a value of the boolean true
      c. a property route with the value of the parseRoute function being called with the argument window.location.hash
        - This properties' role is to decide which screen to show

        * parse-route.js
          - The parseRoute function takes in a hashRoute as an arguement and returns an object with the properties "path" and "params"
          - Within the parseRoute function, it checks if the hashRoute starts with a "#" and chops it off
          - The hashRoute is then split on the "?" and the left side of the question mark is named path, and the right side is named queryString
          - path is used to determine which screen to show
          - URLSearchParams object is used to separate the key value pairs from the queryString

    - the render() method is run once and since this.state.isAuthorizing is equal to true, null is returned
    - After render, the componentDidMount runs and we add an event listener for future hash changes
      a. if the hash of the URL bar changes, the component will be notified and re parse the new hash and update the state (which will trigger a re-render)
    - After the event listener is added, a token is pull from local storage.
    - The token is checked using a ternary operator and at this point, null will be assigned to the const variable user
    - setState is called which assigns the property user to the variable user and the property isAuthorizing equal to false.
    - Since setState has been called, this will trigger a re-render
    - Within the render method, user and route are destructured this.state and assigned into the variables user and route
    - Two methods within App (handleSignIn and handleSignOut) are destructured from "this" and assigned to the variables handleSignIn & handleSignOut
    - User, route, handleSignIn and handleSignOut are then put into an object and assigned to the const variable contextValue which will be used to generate render the page
    - The react element AppContext.Provider is run with the prop of value and the value of the variable contextValue

        * app-content.js
          - The createContext method of the react object is being called and assigned to the const variable AppContext
          - The AppContext variable is being assigned to the default export of the module

    - The react element Navbar is rendered

        * navbar.jsx
          - within the render method iof the Navbar class, user and handleSignOut are destructured from this.context
          - render returns a simple navbar with the Awesome App logo and either a button that allows the user to sign out, or two anchor tags for sign-in and sign-out
          - the two anchor tags have an href of #sign-in or #sign-out which will enable hash routing

    - The react element page-container is rendered

        * page-container.jsx
          - the function PageContainer is defined and returns divs with some styling that will act as the container for all the content rendered on the page

    - Within the page container the renderPage method of the App class is called
    - Within the renderPage method, the property path is destructured from this.state.route and is assign to the const variable path
    - This path variable will be used to determine which page to render (Home, Auth, or NotFound)
    - When the page initially loads, path is equal to "sign-in" so the react element Auth will be rendered.
