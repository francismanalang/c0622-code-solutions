# Database Setup
  * Postgresql is used to create the database reactContext for the information within schema.sql
  * Back-end server code is set up on server/index.js
    - Within index.js, two post routes are defined to respond to the client for when the user is Signing Up and Signing In
      * Sign up
        - If the client did NOT provide a valid user name and password, a ClientError is sent
        - If the client did provide valid inputs, argon2 is used to hash the provided password
        - then, sql code is used to insert the username and hashedPassword into the database
        - userId, username, and createdAt is returned and sent back to the client
      * Sign in
        - If the client did NOT provide a valid user name and password, a ClientError is sent
        - If the client did provide valid inputs, we query the database using sql code to return the userId and hashedPassword from that speciifc username
        - argon2 is used to verify if the hashedPassword and the password provided by the user matches
        - if they do match, a payload is created containing the userId and username
        - jwt.sign() is used to sign a token using the TOKEN_SECRET specified in the env file
        - An object containing the signed token and payload are returned to the client

# Notes
  * Front end is SERVED by the back-end
  * When users go to a website, the browser sends a GET request for an HTML Document.
  * HTML Document includes
    - BootStrap link
    - Font Awesome link
    - Stylesheet link
    - A script for a main.js file
  * Main.js does not is exist but is handled by dev-middelware.js (which includes a bundle of all the client modules and creates a main.js for us)
  * Once the browser recieves the JavaScript code (includes all the indiviual client modules), our front end code will start to get executed.

# Front-End Code
  * index.jsx
    - React, ReactDOM, and the App Component are included in the bundle
    - The root div is grabbed from the HTML Document
    - We create a react root and the application is started by mounting the App component to the root div

  * app.jsx
    - The mounting phase is started in the component lifecycle.
    - The contructor within app.jsx is executed which establishes an initial state. The initial state has:
      a. a property named user with a value of null
      b. a property isAuthorizing and a value of the boolean true
      c. a property route with the value of the parseRoute function being called with the argument window.location.hash
        - This properties' role is to decide which screen to show
    * parse-route.js
      - The parseRoute function takes in a hashRoute as an arguement and returns an object with the properties "path" and "params"
      - Within the parseRoute function, it checks if the hashRoute starts with a "#" and chops it off
      - The hashRoute is then split on the "?" and the left side of the question mark is named path, and the right side is named queryString
      - path is used to determine which screen to show
      - URLSearchParams object is used to separate the key value pairs from the queryString
    - the render() method is run once and since this.state.isAuthorizing is equal to true, null is returned
    - After render, the componentDidMount runs and we add an event listener for future hash changes
      a. if the hash of the URL bar changes, the component will be notified and re parse the new hash and update the state (which will trigger a re-render)
